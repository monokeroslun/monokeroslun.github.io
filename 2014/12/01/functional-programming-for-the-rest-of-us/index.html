<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>functional programming for the rest of us | iRow not Cat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="介绍
程序员们都是拖延症患者。坐下来，然后喝点咖啡，再查个邮件，看看订阅的RSS，读点细分，看看技术网站上的最新文章，浏览一下在编程板块的特定区域的讨论。去吃个饭，然后回来坐坐，对着IDE发会呆。继续重复上午的事情。 不知不觉之中，一天过去了。
只有一件事，隔一会儿会有一些有挑战性的文章出现。如果你看对地方了，你就会在一些天内发现至少一篇。这些文章很难看懂，所以他们开始堆积。不知不觉中，你已经有了">
<meta property="og:type" content="article">
<meta property="og:title" content="functional programming for the rest of us">
<meta property="og:url" content="http://yoursite.com/2014/12/01/functional-programming-for-the-rest-of-us/">
<meta property="og:site_name" content="iRow not Cat">
<meta property="og:description" content="介绍
程序员们都是拖延症患者。坐下来，然后喝点咖啡，再查个邮件，看看订阅的RSS，读点细分，看看技术网站上的最新文章，浏览一下在编程板块的特定区域的讨论。去吃个饭，然后回来坐坐，对着IDE发会呆。继续重复上午的事情。 不知不觉之中，一天过去了。
只有一件事，隔一会儿会有一些有挑战性的文章出现。如果你看对地方了，你就会在一些天内发现至少一篇。这些文章很难看懂，所以他们开始堆积。不知不觉中，你已经有了">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="functional programming for the rest of us">
<meta name="twitter:description" content="介绍
程序员们都是拖延症患者。坐下来，然后喝点咖啡，再查个邮件，看看订阅的RSS，读点细分，看看技术网站上的最新文章，浏览一下在编程板块的特定区域的讨论。去吃个饭，然后回来坐坐，对着IDE发会呆。继续重复上午的事情。 不知不觉之中，一天过去了。
只有一件事，隔一会儿会有一些有挑战性的文章出现。如果你看对地方了，你就会在一些天内发现至少一篇。这些文章很难看懂，所以他们开始堆积。不知不觉中，你已经有了">

  
    <link rel="alternative" href="/atom.xml" title="iRow not Cat" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">iRow not Cat</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Coding, Music, iRow</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-functional-programming-for-the-rest-of-us" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/01/functional-programming-for-the-rest-of-us/" class="article-date">
  <time datetime="2014-12-01T10:24:02.000Z" itemprop="datePublished">12月 1 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      functional programming for the rest of us
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="介绍">介绍</h2>
<p>程序员们都是拖延症患者。坐下来，然后喝点咖啡，再查个邮件，看看订阅的RSS，读点细分，看看技术网站上的最新文章，浏览一下在编程板块的特定区域的讨论。去吃个饭，然后回来坐坐，对着IDE发会呆。继续重复上午的事情。 不知不觉之中，一天过去了。</p>
<p>只有一件事，隔一会儿会有一些有挑战性的文章出现。如果你看对地方了，你就会在一些天内发现至少一篇。这些文章很难看懂，所以他们开始堆积。不知不觉中，你已经有了很多文件和链接你没有看的了。</p>
<p>我不知道你的这些堆积的文件都有什么，我这里是有很对关于函数式编程的。这些通常都是很难看懂的。都是一些学术性的文章，甚至连在华尔街呆了十年的工业人物也不知道什么是函数式编程。如果你问一个花旗银行的项目经理为什么他们用JMS而不用Erlang,他们会说他们不会在工业强度级的应用学术性的语言。问题是，一些复杂的系统中的最重要的需求都是用函数式编程的思想来编写的。有些事情说不通了。。。</p>
<p>确实，FP的文章和论文都是很难读懂的，但是他们本不应该。其实难懂的原因是纯粹来自历史原因。FP概念其实是没有什么难的。考虑到这片文章是通向FP的guide,是一座建立在我们<strong>命令式思维</strong>和FP世界的桥梁。不要放下咖啡，继续读下去，你的同事们就要开始拿你对FP的评论找乐了。</p>
<p>FP是什么，他是怎么产生的，他可以吃嘛？ 如果他像他的拥护者那样说的有用，为什么他没有在工业生产中得以充分的应用呢。为什么只有那些PHD去使用他呢。最重要的是，为什么他这么的难用。。。什么是<em>closure</em>,<em>continuation</em>,<em>currying</em>,<em>lazy evaluation</em>,<em>没有副作用的business</em>,我们怎么能不把一个大学牵扯进来的前提下在工程里使用他们呢？为什么他们与我们神圣的，亲爱的imperative 思维如此的不一样。我们将会在后面的文章中说明。我们现在先解释一下真实世界和学术世界之间的巨大鸿沟吧。答案从一段公园的散步开始。。</p>
<p>乘坐时间旅行机，我们的散步在两千多年前，在一个非常美的晴天。plato和一个美丽的男奴。话题开始转向学术。</p>
<p>-“看这两个学生。。”</p>
<p>-你觉得谁高呢？</p>
<p>-<em>他们同样高啊</em></p>
<p>-你怎么定义同样高这个词？</p>
<p>-他们从我这个位置上来看是一样高的，但是我不能确定除非我走近看看。</p>
<p>plato笑了，他把小男孩引向一个正确的思维，你是想说，这个世界没有绝对的相等是不是？小男孩沉思了一会，说：是的，任何事物都有一点点的不同，即使我们看不到。重点在这里，如果这个世界没有完全的相等，那么perfect equality的定义是什么？小男孩很困惑的说，我不知道了。。</p>
<p>第一个试图去理解数学的本质诞生了，Plato暗示任何事物在这个世界上都仅仅是近似的“完全（perfect）”.他也能意识到我们能够理解“完全“的概念即使我们从来没有遇到过。他总结出了任何完美的数学公式都是在另一个世界上的，我们怎么能通过一个与另一个世界相连的连接知道他们呢？很显然，这个世界没有绝对的圆。但是我们也可以明白什么是一个完美的圆并且我们也可以通过观察描述他。那么，什么是数学？为什么我们的世界要用数学的定律描述呢？那么所有出现在我们世界的现象都能通过数学描述吗？</p>
<p>数学哲学是一个非常复杂的课题。就像许多哲学规则一样，这些规则更擅长抛出问题而不是提供答案。更多的舆论围绕在数学确实是令人迷惑的这个事实上。我们建立了一系列基本的无冲突的原则和一系列的规则去阐述怎样去运用这些规则。我们可以堆砌这些规则去建立更复杂的规则。数学上管这样的方法叫做形式系统或者是calculus.我们可以有效的为俄罗斯方块写一个形式系统如果我们想要的话。事实上，一个俄罗斯方块的实现是一个形式系统，只是使用了一个不普遍的表达方式。</p>
<p><em>princinple: 内在的驱使你去做一些正确的事情。 People develop principles by living with people with principles and seeing the real benefits of such a life.</em></p>
<p><em>rule:A rule externally compels you, through force, threat or punishment, to do the things someone else has deemed good or right. People follow or break rules.</em></p>
<p><em><a href="http://sandradodd.com/rules" target="_blank" rel="external">http://sandradodd.com/rules</a></em></p>
<p><em>形式系统(Formal System),,包含字母,字的集合及由关系组成的有限集合.</em></p>
<p>毛皮动物的文明可能不能明白我们的俄罗斯方块形式系统因为他们只能通过味道感知。他们可能永远不会了解俄罗斯方块形式系统，但是他们可能拥有一个圆形的形式系统。我们可能不能读到因为我们的嗅觉可能没有那么的复杂。一旦你通过形式系统的表达式，在这之下的概念对任何智能的文明都是可理解的。</p>
<p>有趣的是，如果没有智能的文明在这个世界中曾经存在过，对于俄罗斯方块和圆形的形式体系仍然能够站得住脚。这是由于没有人可以去找到他们。如果一个智能的文明出现，就会发现一些形式体系去帮助我们描述我们世界的一些规律。他们也很有可能不会发现俄罗斯方块因为这个世界上没有什么与之相似。俄罗斯方块是形式系统中数不尽例子中的一个，一个谜题，与真实的世界无关。我们甚至不能确认自然数字是否全部与真实世界相似，因为世界被证明是有限的。</p>
<h2 id="a_bit_of_history">a bit of history</h2>
<p>让我们再次改变时间机器的齿轮,这次我们近一点，去90世纪30年代。大萧条正在破坏新世界和旧世界。所有阶级的家庭都被影响到了由于巨大的经济低迷、很少的让人民免受贫穷的庇护所维持着。很少的人民能够在这些庇护所中生活。但是他们存在。我们的兴趣是在普林斯顿大学的数学家们。</p>
<p>新的哥特风格的办公室给了普林斯顿安全天堂的气氛。全世界的逻辑学家都被邀请到普林斯顿大学去构建一个新的部门。当大多数美国人都找不到晚饭，在普林斯顿是如此惬意。</p>
<p>一位叫Alonzo Church的数学家就是生活在如此丰富的生活格调里。 AC在普林斯顿获得理学学士学位并且被说服继续留在研究所。Alonzo感觉这里环境太宽松了。他很少端着杯茶和其他人讨论数学而且他也没有在森林中散步。Alonzo是一个孤独的人：他自己工作的时候产出往往更高。然而Alonzo还是与其他的普林斯顿住民之间的几个人有着固定的联系，他们是Alan Turing, John von Neumann, and Kurt Godel。</p>
<p>这四个人都对形式系统有兴趣。他们没有花很多心思在物理世界里。他们更多的对抽象数学谜题有兴趣。他们的迷惑有很多相同之处。致力于研究关于计算的问题。一个我们拥有机器拥有无穷的计算资源。什么样的问题是我们能够解决的？我们能够自动的解决他们？有些问题为什么没有解决，为什么？不同设计的机器会有同样的能力吗？</p>
<p>这四个人合作开发了一种形式系统叫做lambda calculus.这个系统本质上是一种编程语言针对于他们想象的机器中的一种。这种语言是基于函数的，可以让其他的函数作为参数，并且返回函数作为结果。这个函数被定义为了希腊字符lambda,也就是这个系统的名字。使用这种系统，A有能力去推导出很多上述问题并给出了答案。</p>
<p><strong>原来lambda就是一种函数</strong></p>
<p>独立于AC， AT也进行着相似的工作，他开发了另一种形式系统（现在被叫做Turing machine）,并且或的相似的结论。后来图灵机和lambda演算被证明具有相同的能力。</p>
<p>这就是故事的结束。如果不是因为第二次世界大战的话，我们翻开书页，你可以去看下一页，世界被火焰淹没。US军队和纳粹使用很多火炮。未来提高精确度军队雇佣了一大群数学家去继续计算弹道射击表格所需的微分方程。对于手工计算来说这明显是一个巨大的工作，所以各种装备被开发出来以解决这一问题。第一台用于计算弹道表格的机器由IBM建造，叫做 Mark I —— 它重达5吨，有75万个零件，每秒钟可以做3次运算。</p>
<p>竞赛，理所当然的，不会停止。1949年，艾维克（EDVAC，Electronic Discrete Variable Automatic Computer 离散变量自动电子计算机）崭露头角并且获得了巨大的成功。这是第一个von Neumann架构的例子，同时这也是一个实际的图灵机在现实世界的实现。Alonzo Church当时并不是那么的走运。</p>
<p>1950年麻省（MIT）的一个教授John McCarthy（也是普林斯顿毕业的）开始对Alonzo Church的工作产生了兴趣。在1958年他推出了列表处理语言（List Processing language， Lisp）。Lisp是一个可以在von Neumann计算机上工作的Alonzo的lambda演算实现！很多计算机科学家都认识到了Lisp的表现力。1973年一群麻省人工智能实验室的程序员们开发了一种硬件，并命名为Lisp机——实际上这就是Alonzo的lambda演算的硬件载体实现。</p>
<h2 id="函数式编程">函数式编程</h2>
<p>函数式编程是AC想法的一种实现。不是所有的lambda表达式的想法都能转化成实践因为lambda表达式没有被设计为在有限的物理条件下进行实际工作。因此，像是面向对象的编程，函数式编程像是一组想法而不是一组严格的指导方针。这里有许多函数式编程的语言，并且很多都非常的不同。在这篇文章中，我会阐述函数式编程中最普遍使用的想法使用java来写。在下两节中我们会用java举例，将会做一些改变来将其转换成可用的函数式编程。现在让我们开始我们的探索吧。</p>
<p>Lambda演算式是为了研究与计算相关的问题而设计的。函数式编程，因此，主要的解决计算的问题。并且，惊奇的是，使用函数去做。一个函数式是一个非常基本的单元在函数式编程里。函数会被大多数事物使用，甚至是在最简单的计算里。甚至变量也可以被替换成函数。在函数式编程里，变量是表达式的简单别名。(以便于我们不用把所有代码写在一行中)他们不可以被改变。所以的变量可以被分配一次。在java术语中，所有的单独的变量都被声明为<em>final</em>.</p>
<p><code>final int i = 5;</code><br><code>final int j = i+3;</code></p>
<p>因为所有的变量在FP中都是final的，所以有两个有趣的结论。总得写关键字final不太说得过去，还有既然它们不可变我们为什么还叫它们“变量”呢，好吧。。。变量。我们现在对Java做两个修改：在我们的函数式Java中所有的变量都会默认为final，并且我们从现在起把变量称为“符号”。</p>
<p>到现在为止，你可能会很想知道如何去写一个合理的复杂的东西在我们创建的新语言中。如果任何符号都是不可变的，我们如何能够改变事物的状态呢？ 这不是严格意义上正确的。当A研究lambda算法的时候他没有对保持状态并在一段时间内改变他感兴趣。他感兴趣的是对数据的操作（也叫做计算东西）。但是，Lambda已经被证明与Turing机等价。他可以做命令式编程可以做的。那么，我们怎么获得相同的结果呢？</p>
<p>函数式编程是可以存储状态的，只是他们不用变量。他们使用函数。状态被保存在函数的参数里，在栈里。如果你想去保持状态一会再去改变它，你要写一个递归函数。举个例子，我们写一个函数去递归一个java的字符串。记住，任何我们声明的变量都是final.</p>
<p><code>String reverse(String arg)</code><br><code>if(arg.length==0){</code><br><code>return arg;</code><br><code>}</code><br><code>else{</code><br><code>return reverse(arg.substring(1,arg.length))+arg.substring(0,1);</code><br><code>}</code><br><code>}</code></p>
<p> 这函数很慢，因为它不断的调用自己。（原作者注6）而且它特吃内存，因为它不断重复的分配对象。但是它是函数式的形式。你可能好奇为什么有人会以这种方式编程呢。恩，我这就告诉你。</p>
<p> （原作者注6：很多函数式语言编译器尽可能的通过交替迭代算法对递归函数做了优化。这通称为tail call optimization）</p>
<h2 id="FP的好处">FP的好处</h2>
<p>你可能会想这样可怕的函数是怎么被合理化的，当我开始学这个的的时候我也是这么想的。但是我错了。有非常多的理由说明了用这种风格的好处。他们其中一些是很主观的。比如，人们声称函数式编程更容易理解。我不去考虑这些言论是因为小孩子都知道：情人眼中出西施。幸运的是，这里有很多客观的言论。</p>
<h3 id="Unit_Test">Unit Test</h3>
<p>因为每一个FP里的符号都是final的，所以没有函数会产生副作用。你永远不可能修改东西，也没有一个函数可以修改不在这个作用域内的值。这就说明了唯一影响评价函数的就是他的返回值，然而他的返回值是受到参数影响的。</p>
<p>对于单元测试人员来说简直是一场春梦。你可以在你的程序中测试任何函数并且尽关心它参数的输入。你不用去考虑正确的顺序，或者设置额外的正确的状态。你要做的就是把边缘情况的参数传入函数。如果任何一个在你程序里的函数通过单元测试，你可以对于你软件的质量有更多的自信相对于你使用命令式的语言。在java或者c++中，检查函数的返回值是不充分的，这里有很多外部状态我们需要去验证。但是这些不会在函数式编程里出现。</p>
<h3 id="Debugging">Debugging</h3>
<p>如果函数式编程没有按照你期望中进行，调试起来是很容易的。你可以有能力去复制你的问题因为函数式编程里的错误不会依赖于不相关的在他之前执行的代码路径。在命令式编程里有些bug是时隐时现出现的。因为命令式编程的函数还有可能依赖于其他函数更改外部状态所带来的副作用，所以你甚至必须检查看似和这个Bug无关的代码和步骤。P中这就不是问题——如果一个函数的返回值错了，它永远是错的，这与你之前运行了什么代码是无关的。</p>
<p>一旦你找到了问题，弄清真相就是小事了。这几乎就是很愉快的了。给你的程序打个断点，看看栈中的情况。堆栈中每个函数的每个参数都可以供你检查，就和在命令式编程中一样。但是在命令式编程中这是不够的，因为函数依赖于每一个成员变量，全局变量，还有各个类的状态（这些类还可能依赖于同样的一些东西）。FP中的函数仅依赖于它的参数，而且它们就在你眼前！此外，光检查命令式程序的返回值不能告诉你这个函数是不是正常工作的。你还需要挨着个检查一堆作用域外的对象来看看它们是不是处于正常的状态。FP中你唯一需要做的就是看看返回值是什么。</p>
<p>   跟踪堆栈信息然后看看什么参数被传入以及它们的返回值。直到有一个返回值出现问题，然后你跟进这个有问题的函数逐行的看一遍。重复这一步骤直到你找到问题的所在。</p>
<h3 id="并发">并发</h3>
<p>函数式编程就是为并发而生的。你永远不用担心死锁和竞争   因为你根本不用使用lock！没有任何数据会会被同一个线程更改第二次，更不用说被两个不同的线程更改了。这意味着你可以简单的添加线程并且不用担心那些常规程序中经常发生的烦人的并发问题。</p>
<p>  如果是这样，为什么没有人在大型并发应用中运用FP呢？恩，其实是有的。爱立信设计了一个函数式语言名为Erlang，并且应用于具有高可用性及高可扩展性的电话交换机上。很多其他的企业认识到了Erlang的优势并且开始使用它。我们说的是程控交换和交通控制系统，它们比典型的华尔街系统更具扩展性和可靠性。事实上，Erlang系统并不具有扩展性和可靠性，Java系统才是。Erlang系统只是跟石头一样硬。</p>
<p>并发的故事并未这样结束。如果你的应用本来就是单线程的，编译器仍然能保证在多CPU的情况下优化FP。我们来看看下面这段代码。</p>
<p><code>String s1 = operation1()</code><br><code>String s2 = operation2()</code><br><code>String s3 =concatenate(s1,s2)</code></p>
<p>在函数式语言里编译器会分析代码，分类可能消耗时间的操作，并将他们并发操作。这不是很可能去做在一个命令式的语言里。因为每一个函数都有可能改变外部的状态和函数。在FP，自动分析哪些函数可以并发执行就像自动内联一样简单。硬件厂商无法再让CPU快一些了。他们只能增加内核数量以成倍的提高并发速度。当然他们很轻松的忘了提醒我们，我们花的钱只增加了处理并发问题的能力。这是命令式编程中很小的一部分，但是是函数式编程的100%，因为函数式编程有很多意想不到的并发手段。</p>
<h3 id="热部署">热部署</h3>
<p>在windows很早的时候为了去更新，就需要去重启电脑很多次。在装完一个版本的media 播放器之后。在Windows XP中，这个问题得到了很大的解决，但是仍然不理想（我今天工作的时候更新了一下我的Windows，一个烦人的图标一直在我的系统托盘上，直到我重启我的系统。）。Unix系统一直以来有一个更好的模型。你只需要停止相关的程序就可以安装一个更新，而不是整个OS。尽管这是一个更好的解决方案，但是对于大型的服务器仍然是不可接受的。程控交换系统需要100%的时间都在运行，因为如果在升级的时候出现紧急呼叫，那是很可能要人命的。所以不能像华尔街商行那样每周末停止系统去安装软件更新。</p>
<p>一个理想的状态就是，完全不需要影响的系统的其他部分就可以对需要升级的代码进行更新。在命令式世界，这是不可能的。想想在Java中卸载一个类并且加载一个新的定义。如果我们这么做每一个类的实例都不能用了，因为这个类的状态也跟着丢失了。我们需要去写复杂的版本控制代码。我们需要把实例的数据序列化，销毁实例，创建新实例，加载序列化后的数据，并祈祷着加载代码能确实的将数据迁移到新实例中。在那之前，每一次变动之前我们必须手动写迁移代码。并且我们的迁移代码还必须十分小心，不能让它们破坏对象间的关系。理论上没问题，但是实践起来很难搞。</p>
<p>在函数式编程中所有的状态是通过函数的参数存储在栈中的。这大大的简化了热部署！实际上，我们需要做的只是对比一下生产环境和新版本之间代码，并且部署新代码。剩下的工作语言工具自动就帮你做了！如果你觉得这是科幻小说，我建议你再想想。Erlang工程师直接升级正在运行的系统已经很多年了。</p>
<h3 id="计算机辅助证明与优化">计算机辅助证明与优化</h3>
<p>一个关于函数式编程语言有趣的性质是他们可以使用数学合理化。因为函数式语言仅仅是形式系统的一种实现。所有在纸上的数学操作都会在程序中实现。编译器可以，举个例子来说，把代码转化为等价的且更有效率的代码段，通过数学证明两片代码段是等效的。关系型数据库已经使用这些优化很多年了。没有理由这种技术不能应用在普通的软件开发中。</p>
<h2 id="高阶函数">高阶函数</h2>
<p>我记得当我得知我上述的那些优点的时候我想“恩，这些的确不错，但是如果让我在一个蹩脚的什么都是final的语言中编程的话，什么优点也不能打动我。这是错误的概念。让所有的变量都是final是很蹩脚的在一个命令式语言里，比如java.但是并不是在一个函数式语言里。函数式语言提供了不同类型的抽象工具让你忘记你曾经喜欢更改变量。其中一个工具就是使用高阶函数的能力。</p>
<p>一个函数在这样的语言里与java或者C是很不一样的。这是一个超集-它可以做所有java中函数中可以做的事，而且是更多。我们可以创建一个函数用同样的行为在c中：</p>
<p><code>int add(int i, int j) {</code><br>  <code>return i + j;</code><br><code>}</code></p>
<p> 这与同样的C语言代码有些不同。我们来扩展我们的Java编译器来支持这种模式。当我们输入上面这类的东西编译器会将它们转换成下述Java代码（别忘了，所有变量是final的）：</p>
<p><code>class add_function_t {</code><br>    <code>int add(int i, int j) {</code><br>       <code>return i + j;</code><br>  <code>}</code><br><code>}</code></p>
<p><code>add_function_t add = new add_function_t();</code></p>
<p>add并不是一个真正的函数。它是一个小型的类，并且有一个函数作为它的成员。我们现在可以将add作为其他函数的参数传来传去了，我也可以将它赋给其他的符号。我们可以在运行时创建一个add_function_t并且当我们不再需要它们的时候进行垃圾回收。这样函数就可以与整型或者字符型一样被作为一等对象（first class objects）。而操作其他函数（将它们作为参数）的函数就被称为高阶函数。别让这个名词吓着你，这和Java对象之间互相操作没什么区别（我们可以把对象实例传递至其他对象中）。我们可以叫他们“高阶类”，但是没人关心这个，因为Java背后没有一个强力的学术社区。</p>
<p>但是，你什么时候使用这种高阶函数呢？ 在很长一大段代码你不用去考虑类的时候。当你看到代码被重复的时候，你就会把他们重整为函数。当你看到在你函数中的一段逻辑代码需要在不同情境下表现不同时，你需要使用高阶函数。我们继续举例子：</p>
<p>假设，我们有一段java代码去接收消息，传递他们通过不同的方式，最后传给另一台服务器。</p>
<p><code>class MessageHandler{</code><br><code>void handleMessage(Message msg){</code><br><code>msg.setClientCode(&quot;abcd&quot;);</code><br><code>sendMessage(msg);</code><br><code>}</code><br><code>}</code></p>
<p>&lt;待续。。。&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/12/01/functional-programming-for-the-rest-of-us/" data-id="7x8j649d9g6w47s8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/12/02/λ演算的一些资料/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          λ演算的一些资料
        
      </div>
    </a>
  
  
    <a href="/2014/12/01/函数式编程小记/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">函数式编程小记</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/node-js/">node js</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂七杂八/">杂七杂八</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/12/08/co-4-0-0的用法-from-github/">co 4.0.0的用法 from github</a>
          </li>
        
          <li>
            <a href="/2014/12/05/promise-A-通过实践了解细节/">promise/A+ 通过实践了解细节</a>
          </li>
        
          <li>
            <a href="/2014/12/03/javascript与函数式编程/">javascript与函数式编程</a>
          </li>
        
          <li>
            <a href="/2014/12/03/the-little-schemer前面要说的/">the little schemer前面要说的</a>
          </li>
        
          <li>
            <a href="/2014/12/02/λ演算的一些资料/">λ演算的一些资料</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 monokeros<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>


  </div>
</body>
</html>